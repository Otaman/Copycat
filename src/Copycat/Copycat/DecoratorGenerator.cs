using System.Diagnostics;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Copycat;

[Generator(LanguageNames.CSharp)]
public class DecoratorGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var source = context.SyntaxProvider.ForAttributeWithMetadataName(
            typeof(DecorateAttribute).FullName!,
            (node, token) => IsPartialClass(node), (syntaxContext, token) =>
            {
                var syntax = (ClassDeclarationSyntax)syntaxContext.TargetNode;
                var symbol = (INamedTypeSymbol)syntaxContext.TargetSymbol;
                
                return new SourceContext(syntax, symbol);
            });
        
        context.RegisterSourceOutput(source, (productionContext, classData) =>
        {
            var sw = Stopwatch.StartNew();
            var (classSyntax, classSymbol) = classData;
            
            var finder = new SymbolFinder(classSymbol);
            var interfaceToDecorate = classSymbol.Interfaces.Single();
            
            var gen = GenerateEmptyClassDeclaration(classSyntax);

            var fieldName = finder.FindFieldsOrPropertiesOfType(interfaceToDecorate).SingleOrDefault()?.Name;
            if (fieldName == null)
            {
                fieldName = "_decorated";
                gen = AddDecoratedFieldAndConstructor(gen, interfaceToDecorate, fieldName, finder, classSymbol);
            }

            gen = AddProperties(finder, interfaceToDecorate, gen, fieldName);
            gen = AddEvents(finder, interfaceToDecorate, gen, fieldName);
            gen = AddMethods(finder, interfaceToDecorate, fieldName, gen);

            var cu = CompilationUnit()
                .WithUsings(classSyntax.SyntaxTree.GetCompilationUnitRoot().Usings);

            if (classSymbol.ContainingNamespace is { IsGlobalNamespace: false })
                cu = cu.AddMembers(
                    FileScopedNamespaceDeclaration(ParseName(classSymbol.ContainingNamespace.ToDisplayString()))
                        .WithSemicolonToken(
                            Token(
                                TriviaList(),
                                SyntaxKind.SemicolonToken,
                                TriviaList(LineFeed))));
            
            cu = cu.AddMembers(gen);

            cu = cu.WithLeadingTrivia(cu.GetLeadingTrivia().InsertRange(0, new []
            {
                Comment("// <auto-generated/>"),
                // Comment($"// {DateTime.Now:T} {sw.ElapsedMilliseconds} ms")
            }));
            
            productionContext.AddSource($"{classSymbol.Name}.g.cs", cu.NormalizeWhitespace().ToFullString());
        });
    }

    private static ClassDeclarationSyntax AddEvents(SymbolFinder finder, INamedTypeSymbol interfaceToDecorate, 
        ClassDeclarationSyntax gen, string fieldName)
    {
        var eventsToImplement = finder.FindNotImplementedEvents(interfaceToDecorate);
        if(!eventsToImplement.IsEmpty)
        {
            gen = gen.AddMembers(eventsToImplement
                .Select(x =>
                {
                    var eventSymbol = x;
                    var eventDeclaration = EventDeclaration(
                            IdentifierName(eventSymbol.Type.ToDisplayString()),
                            Identifier(eventSymbol.Name))
                        .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
                        .WithAccessorList(
                            AccessorList(
                                List(
                                    new[]
                                    {
                                        AccessorDeclaration(
                                                SyntaxKind.AddAccessorDeclaration)
                                            .WithExpressionBody(
                                                ArrowExpressionClause(
                                                    AssignmentExpression(
                                                        SyntaxKind.AddAssignmentExpression,
                                                        MemberAccessExpression(
                                                            SyntaxKind.SimpleMemberAccessExpression,
                                                            IdentifierName(fieldName),
                                                            IdentifierName(eventSymbol.Name)),
                                                        IdentifierName("value"))))
                                            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)),
                                        AccessorDeclaration(
                                                SyntaxKind.RemoveAccessorDeclaration)
                                            .WithExpressionBody(
                                                ArrowExpressionClause(
                                                    AssignmentExpression(
                                                        SyntaxKind.SubtractAssignmentExpression,
                                                        MemberAccessExpression(
                                                            SyntaxKind.SimpleMemberAccessExpression,
                                                            IdentifierName(fieldName),
                                                            IdentifierName(eventSymbol.Name)),
                                                        IdentifierName("value"))))
                                            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
                                    })));
                    return eventDeclaration;
                })
                .Cast<MemberDeclarationSyntax>()
                .ToArray());
        }

        return gen;
    }

    private static ClassDeclarationSyntax AddProperties(SymbolFinder finder, INamedTypeSymbol interfaceToDecorate,
        ClassDeclarationSyntax gen, string fieldName)
    {
        var propertiesToImplement = finder.FindNotImplementedProperties(interfaceToDecorate);
        if (!propertiesToImplement.IsEmpty)
        {
            gen = gen.AddMembers(propertiesToImplement
                .Select(x =>
                {
                    var accessors = Enumerable.Empty<AccessorDeclarationSyntax>();
                    if (x.GetMethod != null)
                    {
                        accessors = accessors.Append(
                            AccessorDeclaration(
                                    SyntaxKind.GetAccessorDeclaration)
                                .WithExpressionBody(
                                    ArrowExpressionClause(
                                        MemberAccessExpression(
                                            SyntaxKind.SimpleMemberAccessExpression,
                                            IdentifierName(fieldName),
                                            IdentifierName(x.Name))))
                                .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)));
                    }
                        
                    if (x.SetMethod != null)
                    {
                        accessors = accessors.Append(
                            AccessorDeclaration(
                                    SyntaxKind.SetAccessorDeclaration)
                                .WithExpressionBody(
                                    ArrowExpressionClause(
                                        AssignmentExpression(
                                            SyntaxKind.SimpleAssignmentExpression,
                                            MemberAccessExpression(
                                                SyntaxKind.SimpleMemberAccessExpression,
                                                IdentifierName(fieldName),
                                                IdentifierName(x.Name)),
                                            IdentifierName("value"))))
                                .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)));
                    }

                    var property = PropertyDeclaration(
                            IdentifierName(x.Type.ToDisplayString()),
                            Identifier(x.Name))
                        .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
                        .WithAccessorList(AccessorList(List(accessors)));

                    return property;
                })
                .Cast<MemberDeclarationSyntax>()
                .ToArray());
        }

        return gen;
    }

    private static ClassDeclarationSyntax AddMethods(SymbolFinder finder, INamedTypeSymbol interfaceToDecorate,
        string fieldName, ClassDeclarationSyntax gen)
    {
        var templateSelector = new TemplateSelector(finder.FindTemplates());
        var methodsToImplement = finder.FindNotImplementedMethods(interfaceToDecorate);
        var methods = methodsToImplement
            .Select(x => new
            {
                Method = (MethodDeclarationSyntax) x.DeclaringSyntaxReferences.Single().GetSyntax(),
                Template = templateSelector.FindTemplateForMethod(x)
            })
            .Select(x =>
            {
                var template = x.Template;
                var method = x.Method;
            
                if (template != null)
                {
                    method = method.AddModifiers(Token(
                        template.GenerateCrefComment(),
                        SyntaxKind.PublicKeyword,
                        TriviaList()));
            
                    if (template.HasAsyncKeyword())
                        method = method.AddModifiers(Token(SyntaxKind.AsyncKeyword));
                }
                else
                {
                    method = method.AddModifiers(Token(SyntaxKind.PublicKeyword));
                }
            
                return method.WithBodyFromTemplate(template, fieldName);
            })
            .ToArray();
        gen = gen.AddMembers(methods.Cast<MemberDeclarationSyntax>().ToArray());
        return gen;
    }

    private static ClassDeclarationSyntax AddDecoratedFieldAndConstructor(ClassDeclarationSyntax gen,
        INamedTypeSymbol interfaceToDecorate, string fieldName, SymbolFinder finder, INamedTypeSymbol classSymbol)
    {
        gen = gen.AddMembers(
            FieldDeclaration(
                    VariableDeclaration(
                            IdentifierName(interfaceToDecorate.ToDisplayString()))
                        .WithVariables(
                            SingletonSeparatedList(
                                VariableDeclarator(
                                    Identifier(fieldName)))))
                .WithModifiers(TokenList(Token(SyntaxKind.PrivateKeyword))));

        var constructors = finder.FindConstructors();
        if(constructors.IsEmpty)
        {
            gen = gen.AddMembers(
                ConstructorDeclaration(classSymbol.Name)
                    .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
                    .WithParameterList(
                        ParameterList(
                            SingletonSeparatedList(
                                Parameter(
                                        Identifier(fieldName.Substring(1)))
                                    .WithType(
                                        IdentifierName(interfaceToDecorate.ToDisplayString())))))
                    .WithBody(Block(
                        ExpressionStatement(
                            AssignmentExpression(
                                SyntaxKind.SimpleAssignmentExpression,
                                IdentifierName(fieldName),
                                IdentifierName(fieldName.Substring(1)))))));
        }

        return gen;
    }

    private static ClassDeclarationSyntax GenerateEmptyClassDeclaration(ClassDeclarationSyntax classSyntax)
    {
        ClassDeclarationSyntax gen;
        gen = classSyntax
            .WithBaseList(null)
            .WithAttributeLists(new SyntaxList<AttributeListSyntax>())
            .WithMembers(new SyntaxList<MemberDeclarationSyntax>());
        gen = gen.ReplaceTrivia(gen.DescendantTrivia()
                .Where(trivia => trivia.IsKind(SyntaxKind.SingleLineCommentTrivia) ||
                                 trivia.IsKind(SyntaxKind.MultiLineCommentTrivia)),
            (_, _) => Whitespace(""));
        return gen;
    }

    private static bool IsPartialClass(SyntaxNode node) =>
        node is ClassDeclarationSyntax classDeclaration && 
        classDeclaration.Modifiers.Any(SyntaxKind.PartialKeyword);
    
    private record SourceContext(
        ClassDeclarationSyntax ClassSyntax,
        INamedTypeSymbol ClassSymbol);
}